         ;代码清单9-1
         ;文件名：c09_1.asm
         ;文件说明：用户程序,写入逻辑100扇区
         ;创建日期：2011-4-16 22:03
;本章程序的目的:让RTC定期发出一个中断,当这个中断发生时,执行我们自己编写的中断中断处理代码,访问CMOS RAM,在屏幕上显示一个动态走动的时钟
;===============================================================================
SECTION header vstart=0                     ;定义用户程序头部段 
    program_length  dd program_end          ;程序总长度[0x00]
    
    ;用户程序入口点
    code_entry      dw start                ;偏移地址[0x04]
                    dd section.code.start   ;段地址[0x06] 
    
    realloc_tbl_len dw (header_end-realloc_begin)/4
                                            ;段重定位表项个数[0x0a]
    
    realloc_begin:
    ;段重定位表           
    code_segment    dd section.code.start   ;[0x0c]
    data_segment    dd section.data.start   ;[0x14]
    stack_segment   dd section.stack.start  ;[0x1c]
    
header_end:                
    
;===============================================================================
SECTION code align=16 vstart=0           ;定义代码段（16字节对齐） 
new_int_0x70:;中断处理过程,该中断处理过程的起始地址,这里是绝对地址,在0x10020处,bochs下使用命令u/100 0x10020即可反汇编出本中断处理过程代码,0x10020是这样得到的,首先中断号是0x70,然后要乘以4,得到0x1c0(这是中断入口点在中断向量表中的偏移地址),然后xp/1 0x01c0得到该内存地址存放的数据(0x10020000),高四位是段地址,低四位是偏移地址,左移段地址4位后加上0000得到0x10020,中断向量表中的其他大多数都是0xf000ff53,绝对地址是0xfff53,然后该地址处存放的指令是iret
      push ax                            ;寄存器压栈保护现场,这一点特别重要,中断处理过程必须无痕执行
      push bx                            ;注意注意注意注意注意看下面看下面注意注意注意注意注意注意
      push cx                            ;注意注意注意注意注意看下面看下面注意注意注意注意注意注意
      push dx                            ;注意注意注意注意注意看下面看下面注意注意注意注意注意注意
      push es                            ;注意注意注意注意注意看下面看下面注意注意注意注意注意注意
;关于RTC更新周期结束中断处理过程可以看成另一个程序(进程???线程???),是独立的处理过程,是额外的执行流程,它随时都会发生,但和主程序互不相关
  .w0:;34~40行用于读RTC寄存器A,根据UIP位的状态来决定是等待更新周期结束,还是继续往下执行,UIP位0表示现在访问CMOS RAM中的日期和时间是安全的                                   
      mov al,0x0a                        ;阻断NMI。当然，通常是不必要的,当NMI发生时,整个计算机都应当停止工作,也不在乎中断处理过程能不能正常执行了
      or al,0x80                         ;用or指令将最高位置1再写端口0x70,在访问RTC期间最好阻断NMI,因为0x70端口的最高位是控制NMI中断的开关,当它为0时,允许NMI中断到达处理器,为1时,阻断所有中断
      out 0x70,al                        ;将al中的内容写入0x70端口,以指定访问0x0a端口(CMOS RAM中的寄存器A)
      in al,0x71                         ;读寄存器A,CMOS RAM的访问需要通过两个端口进行,0x70或0x74端口是索引端口,用来指定CMOS RAM内的单元,0x71或0x75是数据端口,用来读写相应单元里的内容
      test al,0x80                       ;测试第7位UIP,test指令顾名思义是用来测试的,可以测试某个寄存器或内存单元里的内容是否带有某个特征,test指令在功能上与and指令是一样的,都是将这两个操作数按位逻辑与,并根据结果设置相应标志位,但是test指令执行后运算结果被丢弃,并不影响两个操作数的内容
      jnz .w0                            ;以上代码对于更新周期结束中断来说(接上面一句,比如要测试al寄存器的第3位是0还是1,可以编写test al,0x80,只要al的第3位是0,执行后结果一定是0000 0000,标志位ZF=1)
                                         ;是不必要的,因为正常情况下访问CMOS RAM中的日期和时间,必须等待RTC更新周期结束,所以上面的判断过程是必须的,也适用于正常的访问过程,但是当前中断处理过程是针对更新周期结束中断的,而当此中断发生时,本身就说明对CMOS RAM的访问是安全的,有999毫秒的时间留给我们,能执行千万跳指令了,所以判断过程是没有必要的,但是加上也无所谓
      xor al,al                          ;如果UIP位是0,ZF=1,继续往下执行42行,否则继续等待RTC更新周期结束,正常情况下访问CMOS RAM中的日期和时间,必须等待RTC更新周期结束,所以上面的判断过程是必须的,这些代码也适用于正常的访问过程
      or al,0x80                         ;但是当前中断处理过程是针对更新周期结束中断的,而此中断发生时,本身就说明对CMOS RAM的访问是安全的,毕竟留的时间有999毫秒,这段时间能执行千万条指令,所以上面的判断过程是不必要的,加上也无所谓
      out 0x70,al
      in al,0x71                         ;读RTC当前时间(秒)
      push ax

      mov al,2
      or al,0x80
      out 0x70,al
      in al,0x71                         ;读RTC当前时间(分)
      push ax

      mov al,4
      or al,0x80
      out 0x70,al
      in al,0x71                         ;读RTC当前时间(时)
      push ax

      mov al,0x0c                        ;寄存器C的索引。且开放NMI 
      out 0x70,al
      in al,0x71                         ;读一下RTC的寄存器C，使得所有中断标志复位,等于告诉RTC中断已经处理,可以继续下一次中断,否则RTC看到中断未被处理,旧不再产生中断信号,只发生一次中断
                                         ;RTC产生中断的原因有很多,可以通多读寄存器C来判断原因,但这里不需要,因为除了更新周期结束中断外,没有其他中断发生,因为其他中断都被关闭了,此处不考虑闹钟和周期性中断的情况 
      mov ax,0xb800
      mov es,ax

      pop ax
      call bcd_to_ascii
      mov bx,12*160 + 36*2               ;从屏幕上的12行36列开始显示

      mov [es:bx],ah
      mov [es:bx+2],al                   ;显示两位小时数字

      mov al,':'
      mov [es:bx+4],al                   ;显示分隔符':'
      not byte [es:bx+5]                 ;反转显示属性 

      pop ax
      call bcd_to_ascii
      mov [es:bx+6],ah
      mov [es:bx+8],al                   ;显示两位分钟数字

      mov al,':'
      mov [es:bx+10],al                  ;显示分隔符':'
      not byte [es:bx+11]                ;反转显示属性以验证RTC更新周期结束中断是每秒发生一次的

      pop ax
      call bcd_to_ascii
      mov [es:bx+12],ah
      mov [es:bx+14],al                  ;显示两位小时数字
;在8259芯片内部有一个8位中断服务寄存器ISR,每一位都对应着一个中断输入引脚,当中段处理过程开始时,8259芯片会将相应的位置1,表明正在服务从该引脚来的中断      
      mov al,0x20                        ;中断结束命令EOI的代码是0x20,如果外部中断是主片处理的,那么中断结束命令只需要发送给主片,端口号0x20,如果是从片,则既要发给从片也要发给主片
      out 0xa0,al                        ;向从片发送 
      out 0x20,al                        ;向主片发送 
;一旦响应了中断,8259中断控制器无法知道该中断什么时候处理结束,同时,如果不清除相应的位,下次从同一引脚出现的中断将得不到处理,这种情况下需要在中断处理过程结尾,显式地对8259芯片编程清除该标志,方法是向8259芯片发送中断结束命令EOI
      pop es                             ;从栈中恢复被中断程序的现场,并用中断返回指令iret返回中断之前的地方
      pop dx
      pop cx
      pop bx
      pop ax

      iret
;该程序运行时,时间每秒更新一次,冒号的显示属性每秒钟翻转一次,不同的是,@字符以很快的速度闪烁,这意味着,把处理器从停机状态唤醒的不单单是实时时钟的更新周期结束中断,还有其他硬件中断
;-------------------------------------------------------------------------------
bcd_to_ascii:                            ;BCD码转ASCII
                                         ;输入：AL=bcd码
                                         ;输出：AX=ascii
      mov ah,al                          ;分拆成两个数字,就是将AL复制一份到AH以方便操作
      and al,0x0f                        ;仅保留低4位,清零高4位
      add al,0x30                        ;转换成ASCII 

      shr ah,4                           ;逻辑右移4位 
      and ah,0x0f                        
      add ah,0x30

      ret

;-------------------------------------------------------------------------------
start:
      mov ax,[stack_segment]
      mov ss,ax                          ;在121~122执行期间,处理器禁止中断
      mov sp,ss_pointer
      mov ax,[data_segment]
      mov ds,ax
      
      mov bx,init_msg                    ;显示初始信息 
      call put_string

      mov bx,inst_msg                    ;显示安装信息 
      call put_string
;为了修改某中断在中断向量表中的登记项,需要先找到它,第132~135行将中断号0x70乘以4,就是它在中断向量表中的偏移
      mov al,0x70                        ;计算机启动后,RTC芯片的中断号默认是0x70,尽管可以通过对8259编程改变,但是没有必要
      mov bl,4
      mul bl                             ;计算0x70号中断在IVT中的偏移
      mov bx,ax                          ;此时BX=0x70号中断在IVT中的偏移

      cli                                ;修改中断向量表时,先用cli指令清中断,防止改动期间发生新的0x70号中断而导致不可预料的后果,此时IF=0,屏蔽中断

      push es                            ;压栈保存ES,并使ES指向中断向量表IVT所在的段
      mov ax,0x0000
      mov es,ax
      mov word [es:bx],new_int_0x70      ;将中断处理过程的偏移地址写入中断向量表0x70号中断处,前两字节是中断处理过程的偏移地址
                                          
      mov word [es:bx+2],cs              ;后两字节是中断处理过程所在的段地址,就是当前段寄存器CS的内容
      pop es                             ;恢复ES
;接下来设置RCT的工作状态,使它能够产生中断信号给8259中断控制器
      mov al,0x0b                        ;RTC寄存器B,CMOS RAM的访问需要通过两个端口进行,0x70或0x74端口是索引端口,用来指定CMOS RAM内的单元,0x71或0x75是数据端口,用来读写相应单元里的内容
      or al,0x80                         ;阻断NMI,这里或0x80运算是没错的,用or指令将最高位置1再写端口0x70,在访问RTC期间最好阻断NMI,因为0x70端口的最高位是控制NMI中断的开关,当它为0时,允许NMI中断到达处理器,为1时,阻断所有中断
      out 0x70,al                        ;其他7个比特实际上用于指定CMOS RAM单元的索引号,所以or al,0x80没有错,我刚开始以为作者错了,差点给他发邮件,自己修改成or al,0x00后编译在写入虚拟机运行并没有出错,可能是因为运行中没有发送0x70号中断(第158页有说明为什么要屏蔽中断)
      mov al,0x12                        ;通过0x71数据端口设置寄存器B，禁止周期性中断，开放更 
      out 0x71,al                        ;新结束后中断，BCD码，24小时制,详情查看寄存器B的各位功能
;第153~155行,读取寄存器C,使之开始产生中断信号,注意,在向索引端口0x70写入的同时也打开了NMI,毕竟这是最后一次在主程序中访问RTC,如果采取周期性
      mov al,0x0c
      out 0x70,al                        ;没有or al,0x80,所以打开了NMI,毕竟这是最后一次在主程序中访问RTC
      in al,0x71                         ;读RTC寄存器C检查中断原因，复位未决的中断状态
;每当更新周期结束中断发生时,RTC就将它的第4位置1,该寄存器C还有一个特点,就是每次读取它后,所有内容自动清零,如果不读取它的话,相应的位没有清零,同样的中断将不再产生
      in al,0xa1                         ;通过端口0xa1读取8259从片的IMR寄存器
      and al,0xfe                        ;用and al,0xfe(1111 1110)指令清除bit 0(此位连接RTC)
      out 0xa1,al                        ;写回此寄存器,于是RTC中断可以被8259处理了
;(解释第157~159行)RTCX芯片设置完后,再来打通它到8259的最后一道屏障,正常情况下8259芯片是不允许RCT中断的,所以需要修改它内部的中断屏蔽器IMR,IMR是一个8位寄存器,位0对应着中断输入引脚IR0,位7对应着引脚IR7,对应位是0时允许中断
      sti                                ;重新开放中断,此时IF=1,响应中断,从这一时刻开始,中断随时都可能发生,也会随时被处理

      mov bx,done_msg                    ;显示安装完成信息 
      call put_string

      mov bx,tips_msg                    ;显示提示信息
      call put_string
      
      mov cx,0xb800
      mov ds,cx
      mov byte [12*160 + 33*2],'@'       ;屏幕第12行，35列显示一个字符@,表达式在编译阶段进行计算
;以下的174~176行构成一个循环,先是停机,接着某个外部中断唤醒处理器恢复执行,一旦处理器的执行点来到hlt指令之后,则立即使它继续处于停机状态      
 .idle:
      hlt                                ;使CPU进入低功耗状态，直到用中断唤醒,相对于jmp $指令,使用hlt指令会大大降低处理器的占用率
      not byte [12*160 + 33*2+1]         ;反转显示属性,not指令执行时会将操作数的每一位反转,0变1,1变0,从显示效果上看,循环将显示属性反转将会取得动画效果,not指令不影响任何标志位
      jmp .idle
;主程序就是这样了,停机-执行-接着停机,与此同时,中断也在不停发生着,处理器还要抽空来执行中断处理过程,RTC的更新周期结束中断处理,该处理过程是从第27行开始
;-------------------------------------------------------------------------------
put_string:                              ;显示串(0结尾)。
                                         ;输入：DS:BX=串地址
         mov cl,[bx]
         or cl,cl                        ;cl=0 ?
         jz .exit                        ;是的，返回主程序 
         call put_char
         inc bx                          ;下一个字符 
         jmp put_string

   .exit:
         ret

;-------------------------------------------------------------------------------
put_char:                                ;显示一个字符
                                         ;输入：cl=字符ascii
         push ax
         push bx
         push cx
         push dx
         push ds
         push es

         ;以下取当前光标位置
         mov dx,0x3d4
         mov al,0x0e
         out dx,al
         mov dx,0x3d5
         in al,dx                        ;高8位 
         mov ah,al

         mov dx,0x3d4
         mov al,0x0f
         out dx,al
         mov dx,0x3d5
         in al,dx                        ;低8位 
         mov bx,ax                       ;BX=代表光标位置的16位数

         cmp cl,0x0d                     ;回车符？
         jnz .put_0a                     ;不是。看看是不是换行等字符 
         mov ax,bx                       
         mov bl,80                       
         div bl
         mul bl
         mov bx,ax
         jmp .set_cursor

 .put_0a:
         cmp cl,0x0a                     ;换行符？
         jnz .put_other                  ;不是，那就正常显示字符 
         add bx,80
         jmp .roll_screen

 .put_other:                             ;正常显示字符
         mov ax,0xb800
         mov es,ax
         shl bx,1
         mov [es:bx],cl

         ;以下将光标位置推进一个字符
         shr bx,1
         add bx,1

 .roll_screen:
         cmp bx,2000                     ;光标超出屏幕？滚屏
         jl .set_cursor

         mov ax,0xb800
         mov ds,ax
         mov es,ax
         cld
         mov si,0xa0
         mov di,0x00
         mov cx,1920
         rep movsw
         mov bx,3840                     ;清除屏幕最底一行
         mov cx,80
 .cls:
         mov word[es:bx],0x0720
         add bx,2
         loop .cls

         mov bx,1920

 .set_cursor:
         mov dx,0x3d4
         mov al,0x0e
         out dx,al
         mov dx,0x3d5
         mov al,bh
         out dx,al
         mov dx,0x3d4
         mov al,0x0f
         out dx,al
         mov dx,0x3d5
         mov al,bl
         out dx,al

         pop es
         pop ds
         pop dx
         pop cx
         pop bx
         pop ax

         ret

;===============================================================================
SECTION data align=16 vstart=0

    init_msg       db 'Starting...',0x0d,0x0a,0
                   
    inst_msg       db 'Installing a new interrupt 70H...',0
    
    done_msg       db 'Done.',0x0d,0x0a,0

    tips_msg       db 'Clock is now working.',0
                   
;===============================================================================
SECTION stack align=16 vstart=0
           
                 resb 256
ss_pointer:
 
;===============================================================================
SECTION program_trail
program_end:
;说明注释:
;为了分享计算机的计算力,处理器应当能为多用户多任务提供硬件一级的支持,在单处理器的系统中,允许同时有多个程序在内存中等待处理器执行
;当一个程序在等待输入时,允许另一个程序从处理器那里得到执行权
;           9.1 外部硬件中断
;外部硬件中断就是从处理器外面来的中断信号,当外部设备发生错误或者有数据要传送,或者处理器交给它的事情完成了,都会告诉处理器来处理
;外部硬件中断是通过两个信号线引入处理器内部的,从8086处理器开始,这两根线就叫NMI和INTR
;
;非屏蔽中断
;来自外部设备的中断很多,并不是每个中断都必须处理,有些中断在任何时候都必须及时处理,事关整个系统的安全性,比如内存访问电路发现了一个校验错
;还有更多的中断是可以被忽略或者延迟处理的,如果这个程序不希望被打扰,所以处理器设计者使用两个引脚来区分不同性质的中断
;首先严重事件都必须无条件加以处理,这类中断是不会被阻断和屏蔽的,称为非屏蔽中断Non Maskable Interrupt
;中断信号的来源,就是产生中断信号的设备称为中断源,在传统的兼容模式下,NMI的中断源通过一个与非门连接到处理器
;处理器的NMI引脚是高电平有效的,而中断信号是低电平有效的,当不存在中断的时候,与非门的所有输入都为高,NMI就为低电平,意味着没有中断发生
;当有任何一个非屏蔽中断发生时,与非门的输出为高,Intel处理器规定,NMI中断信号由0跳变到1后,至少要维持4个时钟周期才是有效的,才能被识别
;上图只是简化的示意图,并非真正的设备连接图,当一个中断发生时,处理器将会通过中断引脚NMI和INTR得到通知,处理器还应当知道发生了什么事,以采取适当的措施
;每种类型的中断都被统一编号,称为中断类型号/中断向量号,但是由于不可屏蔽中断的特性,几乎所有触发NMI中断的事件对处理器来说都是致命的,甚至是不可纠正的
;这种情况下去搞清楚发生了什么通常是没有什么意义的,正是这个原因,在实模式下,NMI都被赋予了统一的中断号2,不进行细分
;一旦发生2号中断,处理器和软件系统通常会放弃要继续的正常工作,也不会试图纠正已经发生的问题和错误,通常由软件系统给出提示信息
;
;可屏蔽中断
;更多时候发往处理器的中断信号通常不意味着灾难,但有时候也会非常紧急,比如计算机控制的机床,当零件通过铣具时,处理器应当立即处理中断,向铣具发送信号进行切削
;这类中断有两个特点,一是数量非常多,二是可以被屏蔽,这类中断称为可屏蔽中断,尽管不处理中断就会把零件铣坏,但是否允许处理器看见该中断,是你自己的事情,处理器赋予你这个权力
;可屏蔽中断是通过INTR引脚引入处理器内部的,像NMI一样,不可能为每一个中断源都提供一个引脚,而且处理器每次只能处理一个中断
;在这种情况下需要一个代理,来接受外部设备发出的中断信号,有时候多个设备同时发出中断信号的可能性也是很高的,代理的任务还包括仲裁,决定哪一个优先向处理器提出服务请求
;个人计算机中用得最多的代理是8259中断控制器,从8086开始一直到现在
;Intel处理器允许256个中断,0~255,8259负责提供其中的15个,但中断号不固定,之所以不固定是因为当初设计的时候,允许软件根据自己的需要灵活设置中断号,防止发生冲突
;8259有自己的端口号,可以使用in和out指令改变它的状态,包括各个引脚的中断号,所以叫可编程中断控制器PIC Programmable Interrupt Controller
;
;每片8259只有8个中断输入引脚,而在个人计算机上使用需要两块,第一块的代理输出INT直接送到处理器的INTR引脚,这是主片Master
;第二块的INT输出送到第一块的引脚2上,是从片Slave,两块芯片形成级联关系Cascade,如此一来可以提供15个中断信号
;当时接在8259芯片上的15个设备都相当重要,如PS/2键盘鼠标,串行口/并行口/软磁盘驱动器/IDE硬盘等,现在淘汰了一些设备,这些中断引脚可以被其他设备使用
;8259主片引脚IR0接的是系统定时器/计数器芯片,从片的引脚IR0接的是实时时钟芯片RTC,这两个固定连接一直持续到现在
;在8259芯片内部有中断屏蔽寄存器IMR Interrupt Mask Register,是8位寄存器,对应着该芯片的8个中断输入引脚,对应的位是0还是1
;决定了从该引脚来的中断信号能否通过8259芯片送往处理器
;0表示允许,1表示阻断,当外部设备通过某个引脚送来一个中断请求信号时,如果没有被IMR阻断,那么可以被送往处理器
;8259芯片是可编程的,主片端口号是0x20和0x21,从片端口号是0xa0和0xa1,可以通过这些端口访问8259并设置工作方式,包括IMR
;
;中断能否被处理,除了8259的IMR,还要看处理器,处理器内部有个IF标志位,当IF=0时,所有从INTR引脚来的中断信号都将被忽略,IF=1,处理器可以接受和响应中断
;IF标志位可以使用cli和sti来改变,cli CLear Interrupt   sti SeT Interrupt
;在计算机内部,中断十分频繁,当一个中断正在处理时,其他中断也会陆续到来,甚至会有多个中断同时发生,8259芯片会记住他们,并按一定策略决定优先级
;总体上说优先级是与引脚相关的,主片的IR0优先级最高,IR7最低,从片也是如此,不过要考虑从片是级联在主片的IR2上
;最后要说的是,当一个中断事件正在处理时,如果来了一个优先级更高的中断,允许暂时终止当前的中断处理,先为优先级较高的中断事件服务,称为中断嵌套
;
;9.1.3 实模式下的中断向量表
;所谓中断处理就是要执行一段与该中断有关的程序,处理器可以识别256个中断,理论上需要256段程序,这些程序的位置不重要,重要的是在实模式下,处理器要求将它们的入口点
;集中存放在内存中从物理地址0x0000开始到0x03ff结束,共1KB的地址空间中,就是所谓的中断向量表IVT Interrupt Vector Table
;每个中断向量在向量表中占用4字节,分别是中断处理程序的偏移地址和段基地址,中断0的入口点位于物理地址0x0000处,也就是逻辑地址0x0000:0x0000处
;中断1的入口点位于物理地址0x0004处,也就是逻辑地址0x0000:0x0004处,以此类推
;
;当中断发生时,如果从外部硬件到处理器之间的道路是畅通的,那么处理器在执行完当前的指令后,会立即着手为硬件服务
;处理器首先会响应中断,告诉8259芯片准备着手处理该中断,接着要求8259芯片把中断号送过来
;在8259芯片那里,每个引脚都被赋予了一个中断号,而且这些中断号是可以改变的,可以对8259编程看来改变,但不能单独进行,只能以芯片为单位进行
;比如可以指定主片的中断号从0x08开始,那么它每个引脚IR0~IR7所对应的中断号分别是0x08~0x0F
;中断信号来自哪个引脚,8259是最清楚的,所以8259会把对应的中断号告诉处理器,处理器拿着这个中断号,顺序做以下几件事情
;     1.保护断点的现场首先要将标志寄存器FLAGS压栈保存,然后清除IF和TF位,TF是陷阱标志,以后涉及,接着再将当前的代码段的CS和IP压栈
;     2.执行中断处理程序,由于处理器已经拿到中断号,将该号码乘以4得到该中断入口点在中断向量表中的偏移地址
;       接着从表中依次取出中断处理程序的偏移地址和段基地址,分别传送到CS和IP,处理器就开始执行中断处理程序了
;       由于IF被清零了,在中断处理过程中,处理器将不再响应硬件中断,如果希望更高优先级的中断嵌套,可以在编写中断处理程序时,适时使用sti开放中断
;     3.返回到断点接着执行,所有中断处理程序的最后一条指令都必须是iret,iret没有操作数,执行时处理器依次从栈中弹出IP/CS/FLAGS的原始内容,转到主程序接着执行
;       中断处理过程返回时,已经恢复了FLAGS的内容,IF也恢复了,可以响应新的中断
;
;和可屏蔽中断不同,NMI中断发生时处理器不会从外部获得中断号,自动生成中断号2,其他过程与可屏蔽中断一样
;中断随时可能发生,中断向量表的建立和初始化是由BIOS在计算机启动时负责完成的,BIOS为每一个中断号填写入口地址,因为BIOS不知道多数中断处理程序的位置
;所以一律将它们指向同一个入口,在那里只有一条iret指令,也就是当那些中断发生时,只做一件事,就是立即返回
;当计算机启动后,操作系统再根据自己的需要来修改某些中断的入口地址,使之指向自己的代码,本章就是这样做的
;
;xp查看中断向量表时,大多数中断向量表表项都是0xF000 FF53,反汇编物理地址0xFFF53的代码就是iret(Intel处理器低端字节序,0xF000段基地址,0xFF53段内偏移)
;
;9.1.4 实时时钟/CMOS RAM和BCD编码
;为什么计算机能够准确地显示时钟和日期,原因在于在外围设备控制器ICH内部集成了实时时钟电路Real Time Clock和两小块由互补金属氧化物(CMOS)材料组成的静态存储器
;实时时钟电路负责计时,而时间和日期的数值则存储在这块存储器中
;实时时钟是全天候跳动的,即使是在关闭计算机电源之后,原因在于它由主板上的小电池提供能量,为整台计算机提供一个基准时间,为所有需要时间的软件和硬件服务
;早期的计算机没有ICH芯片,各个接口单元都是分立的,单独地焊在主板上,并彼此连接,早期的RTC是摩托罗拉的MS146818B,现在直接集成在ICH内,并且信号上与其兼容
;除了时间和日期的保存功能之外,RTC也可以提供闹钟和周期性中断功能
;日期和时间信息是保存在CMOS RAM中的,通常有128字节,而且日期和时间信息只占用了一小部分内容,其他空间则用于保存整机的配置信息,比如各个硬件的类型和工作参数
;开机密码,辅助存储设备的启动顺序等,这些参数的修改通常指BIOS SETUP程序中进行
;RTC芯片由一个振荡频率为32.768kHz的石英晶体振荡器驱动,经分频后,用于对CMOS RAM进行每秒一次的时间刷新
;常规的时间和日期信息占据了CMOS RAM开始部分的10字节,报警的时分秒用于产生到时间报警中断,如果它们的内容是0x0C~0xFF,表示不使用报警功能
;
;CMOS RAM中的时间信息
;偏移地址     内容
;
;0x00         秒   
;0x01        闹钟秒
;0x02         分
;0x03        闹钟分
;0x04         时
;0x05        闹钟时
;0x06        星期
;0x07         日
;0x08         月
;0x09         年
;0x0A       寄存器A
;0x0B       寄存器B
;0x0C       寄存器C
;0x0D       寄存器D
;对CMOS RAM的访问,需要通过两个端口来进行,0x70或0x74是索引端口,用来指定CMOS RAM中的单元
;0x71或0x75是数据端口,用来读写相应的单元,以下代码用于读取星期几:
;     mov al,0x06
;     out 0x70,al
;     in al,0x71
;从很早开始值到现在,0x70端口的最高位是控制NMI中断的开关,当它为0时,允许NMI中断到达处理器,为1时,阻断所有中断,其他7个比特实际上用于指定CMOS RAM单元的索引号
;如下图所示
;尽管端口0x70的位7不是中断信号,但它能够控制与非门(或非门???)的输出,决定真正的NMI中断信号是否能够到达处理器
;
;通常来说,再往0x70端口写入索引时,应当先读取其中的内容,但是该端口是只写的,不能用于读出,早期的计算机制造成本高,为了最大化利用硬件资源,才有这种做法
;为了解决这个问题,同时为了兼容老式硬件,ICH芯片允许通过切换访问模式来临时取得那些只写寄存器的内容,但这涉及到更高层次的知识
;现在将问题简单化,NMI中断应当始终是允许的,在访问RTC时,我们直接关闭NMI,访问结束后再打开NMI,而不管它以前是什么样的
;
;在早期,CMOS RAM只有64字节,而最新的ICH则可能集成了256字节,新增的128字节称为扩展的CMOS RAM,要确保ICH内确实存在扩展的CMOS RAM
;CMOS RAM中保存的时间和日期,通常默认以二进制编码的十进制数BCD Binary Coded Decimal来表示,根据需要也可以设置成正常的二进制表示
;BCD 一个字节的高4位和低4位分别独立地表示一个0~9之间的数字,比如25对应的二进制是0001 1001,而BCD码表示成0010 0101
;
;单元0x0A~0x0D不是普通的存储单元,而被定义成4个寄存器的索引号,也是通过0x70和0x71这两个端口访问的,这4个寄存器用于设置实时时钟电路的参数和工作状态
;寄存器A和B都是8位寄存器,用于对RTC功能进行整体性调整,可读可写,用途如下表
;寄存器A
;     比特位      功能
;       7     正处于更新过程中UIP Update In Progress
;             该位可以作为一个状态进行监视,CMOS RAM中的时间和日期信息会由RTC周期性地更新,在此期间,用户程序不应当访问它们,对当前寄存器的写入不会改变此位的状态
;             0:更新周期至少在488微秒内不会启动,此时访问CMOS RAM中的时间/日历和闹钟信息是安全的
;             1:正处于更新周期或者马上就要启动
;             如果寄存器B的SET位不是1,而且在分频电路已正确配置的情况下,更新周期每秒发生一次,在此期间会增加保存的日期和时间/检查数据是否因超出范围而溢出(比如31号后面是1号而不是32号)
;             还要检查是否到了闹钟时间,最后更新之后的数据还要写回原来的位置
;             更新周期至少会在UIP置1后的488us内开始,而且整个周期的完成的时间不会多于1984us,在此期间,和日期时间有关的存储单元0x00~0x09会暂时脱离外部总线,为避免更新和数据遭到破坏
;             可以有两次安全地从外部访问这些单元的机会:
;                 当检测到更新结束中断发生时,可以有差不多999ms的时间用于读写有效的日期和时间数据
;                 如果检测到寄存器A的UIP位为0,那么意味着在更新周期开始前,至少还有488us的时间
;
;
;      6~4   分频电路选择Division Chain Select  这3位控制晶体振荡器的分频电路系统将其初始化到010,为RTC选择一个32.768kHz的时钟频率 
;
;      3~0   速率选择RS Rate Select             选择分频电路的分节点,如果寄存器B的PIE位被设置的话,此处的选择将产生一个周期性的中断信号,否则将设置寄存器C的PF标志位
;            0000:从不触发中断
;            0001:3.90625ms
;            0010:7.8125ms
;            0011:122.070us
;            0100:244.141us
;            0101:488.281us
;            0110:976.5625us
;            0111:1.953125ms
;            1000:3.90625ms
;            1001:7.8125ms
;            1010:5.625ms
;            1011:1.25ms
;            1100:62.5ms
;            1101:125ms
;            1110:250ms
;            1111:500ms
;
;这里主要涉及到寄存器B
;     比特位      功能
;       7   更新周期禁止Update Cycle Inhibit
;           0:更新周期每秒都会正常发生
;           1:中止当前的更新周期,并且此后不再产生更新周期,此位置1时,BIOS可以安全地初始化日历和时间
;
;       6   周期性中断允许PIE Periodic Interrupt Enable
;           0:不允许
;           1:当达到寄存器A中RS所设定的时间基准时,允许产生中断
;
;       5   闹钟中断允许AIE Alarm Interrupt Enable
;           0:不允许
;           1:允许更新周期在到达闹点并将AF置位的同时发出一个中断
;
;       4   更新结束中断允许UIE Update-Ended Interrupt Enable
;           0:不允许
;           1:允许在每个更新周期结束时产生中断
;
;       3   方波允许SQWE Square Wave Enable
;           该位空着不用,只是为了和早期的摩托罗拉146818B实时时钟芯片保持一致
;
;       2   数据模式DM Data Mode
;           0:BCD
;           1:Binary
;
;       1   小时格式 HOURFORM Hour Format
;           0:12小时制,第七位0表示上午,1表示下午
;           1:24小时制
;
;       0   老软件的夏令时支持DSLSWS Daylight Savings Legacy Software Support,已不再支持,仅仅用于对老软件的支持,而且是无用的
;
;
;寄存器C和D是8位标志寄存器,反映了当前RTC的工作状态,寄存器C是只读的,寄存器D可读可写
;RTC可以产生中断,当中断产生时,可以通过寄存器C来识别中断原因,比如是周期性中断还是闹钟中断
;寄存器C
;     比特位      功能
;       7   中断请求标志IRQF Interrupt Request Flag
;           IRQF = (PF x PIE) + (AF x AIE) + (UF x UFE)
;           加号表示逻辑或,乘号表示逻辑与,该位被设置时,表示肯定要发生中断,对寄存器C的读操作将导致此位清零
;
;       6   周期性中断标志PF Periodic Interrupt Flag
;           如果寄存器A的RS位为0000,则此位是1,对寄存器C的读操作将导致此位清零
;           程序可以根据此位来判断RTC的中断原因
;
;       5   闹钟标志AF Alarm Flag
;           当所有闹点同当前时间相符时,此位是1,对寄存器C的读操作将导致此位清零
;           程序可以根据此位来判断RTC的中断原因
;
;       4   更新结束标志UF Update-Ended Flag
;           紧接着每秒一次的更新周期之后,RTC电路立即将此位置1,对寄存器C的读操作将导致此位清零
;           程序可以根据此位来判断RTC的中断原因
;
;      3~0  保留,总是报告0
;
;
;寄存器D
;     比特位      功能
;       7   有效RAM和时间位VRT Valid RAM and Time Bit
;           在写周期,此位应该始终写0,不过在读周期,此位回到1,在RTC加电正常时,此位被硬件强制为1
;
;       6   保留,总是返回0,并且在写周期总是置0
;
;      5~0  保留,总是报告0
;
;本章程序的目的
;本章程序的目的
;本章程序的目的
;本章程序的目的:让RTC定期发出一个中断,当这个中断发生时,执行我们自己编写的中断中断处理代码,访问CMOS RAM,在屏幕上显示一个动态走动的时钟
;
;
;9.1.6 初始化8259/RTC/中断向量表IVT
;本章的加载器使用上一章的加载器
;首先强调一点,当处理器执行任何一条改变栈段寄存器SS的指令时,它会在下一条指令执行完期间禁止中断,栈无疑是很重要的,不能被破坏,如果要改变代码段和数据段,只需要改变段寄存器就可以了
;但栈段不同,因为除了有SS外还有SP,因此绝大多数时候,对栈的改变是分两步进行的,先改变SS,再改变SP
;想象一下,如果刚刚修改SS,还没来得及修改SP就发生了中断,中断还要依靠栈工作
;因此处理器在设计之初就规定,当遇到修改SS的指令时,在这条指令和下一条指令执行完毕期间,禁止中断,以此来保护栈,换句话说,程序员应当在修改SS指令之后,紧跟着一条修改SP的指令
;     push cs
;     pop ss
;     mov sp,0
;在后两条指令执行期间,处理器禁止中断
;RTC芯片的中断信号通向8259从片的IR0,在计算机启动期间,BIOS会初始化中断控制器,将主片的中断号设为从0x08开始,将从片的中断号设为从0x70开始
;所以计算机启动后,RTC芯片的中断号默认是0x70,尽管可以通过对8259编程来改变,但是没有必要
;
;RTC到8259的中断线只有一条,而RTC可以产生多种中断,比如闹钟中断/更新结束中断/周期性中断,RTC的计时(更新周期)是独立的,产生中断信号只是附赠
;如果希望RTC能够产生中断信号,需要额外设置,只需要设置一种即可,最简单的就是设置更新周期结束中断
;每当RTC更新了CMOS RAM中的时间和日期后,将发出此中断,更新周期每秒进行一次,因此该中断也每秒发生一次
;为了设置该中断,第147行,将RTC寄存器B的索引0x0b写入al,在访问RTC期间,最好是阻断NMI,因此第147~149行,先用or指令将al最高位置1,再写端口0x70
;每次当中断实际发生的时候,可以在中断处理过程中读寄存器C的内容来检查中断原因,比如每当更新周期结束中断发生时,RTC就将它的第4位置1
;每次读取它之后,所有内容自动清零,如果不读取,相应的位没有清零,同样的中断不会再次产生
;第153~155行,读取寄存器C,使之开始产生中断信号,注意,在向索引端口0x70写入的同时也打开了NMI,毕竟这是最后一次在主程序中访问RTC
;如果采取周期性中断而不是更新周期结束中断,稍微麻烦一些,因为要设置分频电路的分节点,以下代码片端用于产生两秒一次的周期性中断
;     mov al,0x0a
;     or al,0x80
;     out 0x70,al
;     in al,0x71
;     or al,0x0f  ;设置RTC寄存器A使之每秒发生两次中断
;     out 0x71,al
;除此之外还要设置寄存器B的PIE位,允许周期性中断
;接下来打通到8259的最后一道屏障
;
;9.1.8 实时时钟中断处理过程看代码