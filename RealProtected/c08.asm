         ;代码清单8-2
         ;文件名：c08.asm
         ;文件说明：用户程序,好像有bug,在linux下用bochs运行测试时,字符串显示不完整就进入无限循环,其实是自己粗心大意了,哪有什么bug,真是罪过罪过
         ;创建日期：2011-5-5 18:17
;dd if=c08.bin of=BochsHD bs=512 count=2 seek=100 conv=notrunc,应该写入两个块的内容才对,将msg0字符串加长就可以看到滚屏了
;===============================================================================
SECTION header vstart=0                     ;定义用户程序头部段 
    program_length  dd program_end          ;标号program_end所代表的汇编地址在数值上等于程序总长度[0x00],此处及以下代码注释中由中括号括起来的十六进制数是当前代码的汇编地址,这条指令的汇编地址是0x00
    ;该段地址仅仅是编译阶段确定的段地址,当用户程序加载到内存中时,需根据加载的位置重新计算,尽管在16位环境中,一个段最长位64KB,但是却可以起始于任何20位的物理地址处,不能用16位保存20位的地址,所以用32位保存
    ;声明并初始化用户程序入口点
    code_entry      dw start                ;标号start=偏移地址,vstart=0子句,所以标号start所代表的汇编地址是相对于当前代码段code_1的起始位置,从0开始[0x04]
                    dd section.code_1.start ;表达式section.code_1.start=段地址[0x06],加载器重定位完后将回填修正后的入口点代码段基址,就是将刚才计算出来的逻辑段地址写回原处,仅覆盖低16位
    
    realloc_tbl_len dw (header_end-code_1_segment)/4
                                            ;段重定位表项个数[0x0a]
    ;段重定位表项个数是在编译阶段确定的
    ;实际的段重定位表,每个表项用一个dd声明一个双字,5个表项依次计算段开始汇编地址的表达式并进行初始化
    code_1_segment  dd section.code_1.start ;[0x0c]加载器重定位完后将回填修正后的段的基址
    code_2_segment  dd section.code_2.start ;[0x10]加载器重定位完后将回填修正后的段的基址
    data_1_segment  dd section.data_1.start ;[0x14]加载器重定位完后将回填修正后的段的基址
    data_2_segment  dd section.data_2.start ;[0x18]加载器重定位完后将回填修正后的段的基址
    stack_segment   dd section.stack.start  ;[0x1c]加载器重定位完后将回填修正后的段的基址
    
    header_end:                
    
;===============================================================================
SECTION code_1 align=16 vstart=0         ;定义代码段1（16字节对齐） 
put_string:                              ;显示串(0结尾)。
                                         ;输入：DS:BX=串地址
         mov cl,[bx]                     ;一个数和它自己做或运算结果是它自己,但会影响标志寄存器的某些位,如果ZF置位,则表示取到了字符串结束标志0
         or cl,cl                        ;cl=0 ?0表示字符串结束
         jz .exit                        ;是的，返回主程序
         call put_char                   ;不是0,则转移到put_char显示字符
         inc bx                          ;过程put_char返回后令BX指向下一个字符 
         jmp put_string                  ;再次调用put_string
;这个过程循环从DS:BX取得单个字符,判断是否为0,不为0则调用另一个过程put_char,为0则返回主程序
   .exit:
         ret                             ;返回主程序

;-------------------------------------------------------------------------------
put_char:                                ;显示一个字符,并能判断回车和换行,还能在超过屏幕上最后一行的时候上滚内容,并使用光标跟随
                                         ;输入：cl=字符ascii
         push ax
         push bx
         push cx
         push dx
         push ds
         push es

         ;以下取当前光标位置,通过索引端口0x3d4告诉显卡要操作0x0e寄存器
         mov dx,0x3d4
         mov al,0x0e
         out dx,al
         mov dx,0x3d5
         in al,dx                        ;高8位,通过数据端口0x3d5读出1字节的数据并传送到AH中,这是屏幕光标位置的高8位
         mov ah,al
;同样,58~62行从0x0f号寄存器读出光标位置的低8位
         mov dx,0x3d4
         mov al,0x0f
         out dx,al
         mov dx,0x3d5
         in al,dx                        ;低8位 
         mov bx,ax                       ;BX=代表光标位置的16位数
;得到光标位置后,先判断要显示的字符是不是0x0d回车符,是,继续往下执行
         cmp cl,0x0d                     ;0x0d回车符？
         jnz .put_0a                     ;不是。看看是不是换行等字符 
         mov ax,bx                       ;此句略显多余，但去掉后还得改书，麻烦 
         mov bl,80                       ;如果是0x0d回车符,那么应该将光标移动到当前行的行首,每行有80个字符,那么用当前光标位置除以80就可以得到当前行的行号,余数不要,再乘以80就是当前行行首的光标数值
         div bl
         mul bl                          ;mul指令执行后,要是结果的高一半全是0,则OF和CF清零,否则置1,对SF/ZF/AF/PF未定义
         mov bx,ax                       ;AX=当前行首的光标值,传送到BX
         jmp .set_cursor                 ;得到光标值后跳转到设定光标的过程.set_cursor

 .put_0a:;如果要显示的字符不是0x0d回车符,那么它有可能是0x0a换行符
         cmp cl,0x0a                     ;0x0a换行符？
         jnz .put_other                  ;不是，那就正常显示字符,是就往下执行换行符动作,只需要将BX加上80,即可得到新的光标位置,但是如果光标原本就在屏幕最后一行,那么换行就要滚屏了
         add bx,80
         jmp .roll_screen                ;跳到是否滚屏例程,根据情况是否滚屏
;在标准模式下,屏幕上可以同时显示2000个字符,光标占用一个字符的位置,但是整个屏幕只有一个,只能出现在2000个字符中的一个上,典型地,程序员要用光标位置来记录和跟踪下一个字符应当显示在什么地方
 .put_other:                             ;正常显示字符例程      ;光标用来指示字符的位置,而一个字符对应显存中的两个字节,可以将光标位置乘以2来得到该位置字符在显存中的偏移地址
         mov ax,0xb800                   ;令ES附加段指向显存,过程开始处已经将ES压栈了,可以自由使用
         mov es,ax
         shl bx,1                        ;相当于光标数值乘以2,得到该位置字符在显存中的偏移地址
         mov [es:bx],cl                  ;将BX作为偏移,将字符写入显存,无需重写字符显示属性,原来显存里全是白底黑字的空白字符,过程put_char是以黑底白字显示字符的

         ;以下将光标位置推进一个字符
         shr bx,1                        ;将BX除以2,恢复光标位置身份
         add bx,1                        ;将其增加1,推进到下一个位置,因为还没有设置光标
;不管是换行还是正常显示字符后推进光标,都会使BX超过1999,下面判断这个情况并决定是否滚屏
 .roll_screen:
         cmp bx,2000                     ;光标超出屏幕？滚屏
         jl .set_cursor                  ;小于2000则转移到设置光标,大于2000则滚屏
;下面开始滚屏,实质上就是将第2~25行的内容整体往上提一行,最后用黑底白字空白填充第25行(以1开始计数),为了加快速度,这里采用将数据从一个内存区域搬运到另一个内存区域的做法,核心是movsw
         mov ax,0xb800                   ;第94~101行,设定源区域从显存内偏移为0x0a(第2行第1列)的地方开始,该区域的段地址在DS中,偏移在SI中
         mov ds,ax                       ;目标区域从显存内偏移为0x00(第1行第1列)的地方开始,该区域的段地址在ES中,偏移在DI中
         mov es,ax
         cld                             ;设置方向标志
         mov si,0xa0
         mov di,0x00
         mov cx,1920                     ;设定要传送的字数(24乘以80等于1920)
         rep movsw                       ;执行rep movsw传送
         mov bx,3840                     ;清除屏幕最底一行,第25行第1列在显存中的偏移是3840
         mov cx,80
 .cls:                                   ;以黑底白字写入空白字符0x20
         mov word[es:bx],0x0720
         add bx,2
         loop .cls
;不管是回车还是换行,还是显示可打印的字符,上面的各处都给出了光标位置的新数值,下面的工作就是按给出的数值在屏幕上设置光标
         mov bx,1920                    ;滚屏之后,光标应位于最后一行的第一列,数值为1920,将这个字传入BX中,准备设置光标
;第112~123行,通过索引端口指定光标寄存器0x0e和0x0f,并分别将寄存器BX中的高8位和低8位通过数据端口0x3d5写入它们
 .set_cursor:
         mov dx,0x3d4
         mov al,0x0e
         out dx,al
         mov dx,0x3d5
         mov al,bh
         out dx,al
         mov dx,0x3d4
         mov al,0x0f
         out dx,al
         mov dx,0x3d5
         mov al,bl
         out dx,al

         pop es
         pop ds
         pop dx
         pop cx
         pop bx
         pop ax

         ret
;重置光标完成后表示一个字符显示完成,指令ret指令从栈中恢复ip,返回到调用者put_string中,当字符串msg0中的所有字符都显示完成后,过程put_string返回到用户主程序,从第147行接着往下执行
;-------------------------------------------------------------------------------
  start:                                  ;应用程序入口点
         ;初始执行时，DS和ES指向用户程序头部段
         mov ax,[stack_segment]           ;设置到用户程序自己的堆栈 
         mov ss,ax
         mov sp,stack_end                 ;等价于mov sp,256
;栈切换完毕后,从用户程序头部段取得数据段data_1的段地址,并传送到DS,从此DS不再指向段header,不能再用它访问用户程序头部段了,可见各个段寄存器的初始化顺序很重要,如果先初始化数据段和附加段,那么header段的内容将无法访问
         mov ax,[data_1_segment]          ;设置到用户程序自己的数据段
         mov ds,ax

         mov bx,msg0                      ;vstart=0,msg0=0
         call put_string                  ;显示第一段信息 

         push word [es:code_2_segment]    ;使用retf模拟段间返回,此时es=0x1000是用户程序头部段基地址
         mov ax,begin
         push ax                          ;可以直接push begin,80386+,8086不能在栈中压入立即数,之后的处理器可以
         
         retf                             ;转移到代码段2执行
;第154~155行,自从进入用户程序之后,ES一直是指向头部段header的,所以这两条指令用于将第二个数据段data_2的段地址传送到DS,等于换了一个数据段
  continue:
         mov ax,[es:data_2_segment]       ;段寄存器DS切换到数据段2 
         mov ds,ax
         
         mov bx,msg1                      ;将刚才那个字符串的起始偏移地址传送到bx
         call put_string                  ;从屏幕光标处显示第二段信息 

         jmp $                            ;无限循环

;===============================================================================
SECTION code_2 align=16 vstart=0          ;定义代码段2（16字节对齐）

  begin:
         push word [es:code_1_segment]
         mov ax,continue
         push ax                          ;可以直接push continue,80386+
         
         retf                             ;转移到代码段1接着执行 
         
;===============================================================================
SECTION data_1 align=16 vstart=0
;分别声明,编译后依然是紧挨在一起的,vstart=0,所以msg0的汇编地址是从该段起始处0开始计算的
    msg0 db '  This is NASM - the famous Netwide Assembler. '
         db 'Back at SourceForge and in intensive development! '
         db 'Get the current versions from http://www.nasm.us/.'
         db 0x0d,0x0a,0x0d,0x0a
         db '  Example code for calculate 1+2+...+1000:',0x0d,0x0a,0x0d,0x0a
         db '     xor dx,dx',0x0d,0x0a
         db '     xor ax,ax',0x0d,0x0a
         db '     xor cx,cx',0x0d,0x0a
         db '  @@:',0x0d,0x0a
         db '     inc cx',0x0d,0x0a
         db '     add ax,cx',0x0d,0x0a
         db '     adc dx,0',0x0d,0x0a
         db '     inc cx',0x0d,0x0a
         db '     cmp cx,1000',0x0d,0x0a
         db '     jle @@',0x0d,0x0a
         db '     ... ...(Some other codes)',0x0d,0x0a,0x0d,0x0a
         db 0

;===============================================================================
SECTION data_2 align=16 vstart=0

    msg1 db '  The above contents is written by LeeChung. '
         db '2011-05-06'
         db 0

;===============================================================================
SECTION stack align=16 vstart=0
           
         resb 256                         ;保留256字节的栈空间,此处声明了未初始化的空间,编译时会产生警告信息

stack_end:  

;===============================================================================
SECTION trail align=16
program_end:
;===============================================================================
;处理器的工作模式是将内存分成逻辑上的段,指令和数据的获取一律按段地址:偏移地址进行,一个规范的程序应当包括代码段,数据段,附加段和栈段
;这样段的划分在程序加载到内存之前就已经准备好,NASM使用汇编指令SECTION或者SEGMENT定义段,一旦定义段,后面的内容就都属于该段,除非又出现另一个段
;有时候程序并不以一个段定义语句开始,这些内容默认成为一个段
;Intel处理器要求段在内存中的起始物理地址起码是16字节对齐的,即物理地址必须是16的倍数
;相应的在汇编源程序中定义的段,也有对齐的要求,具体做法是使用align=子句,指定某个SECTION的汇编地址对齐方式,align=16/32
;编译器在程序编译阶段将根据align子句确定段的起始汇编地址,比如这里分别定义了三个段,每个段里只有一个字节数据
;section data1 align=16
;       db 0x55
;section data2 align=16
;       db 0xaa
;section data3 align=16
;       db 0x99
;如果不考虑段的对齐方式,段data1的汇编地址是0,段data2的汇编地址是1,段data3的汇编地址是2
;但是这里每个段的定义中都包含了align=16子句,编译后的内容如下
;55 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
;aa 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
;99
;段的汇编地址实际上是段内第一个元素的汇编地址,段data1的声明的0x55位于汇编地址0x00000000处
;段data2也要求16字节对齐,只有0x00000010才能被16整除,于是编译器将0x00000010作为段data2的汇编地址,并在两个段之间填充15字节的0x00(段data1只有1字节长度)
;每个段都有汇编地址,它是相对于整个程序的开头0的,为了方便取得该段的汇编地址,NASM编译器提供了以下表达式
;       section.段名称.start
;下面是一个汇编语言源程序
;                       ________________________________________________________________________
;包含一些注释                    /|\                             /|\                            /|\
;                               |                               |                              |
;                               |                               |                              |
;                     section.header.start=0                    |                              |
;                               |                               |                              |
;                               |                               |                              |
;SECTION header vsart=0 _______\|/_______________               |                              |
;       .                                                       |                              |
;       .                                               section.code.start                     |
;       .                                                       |                              |
;SECTION code align=16 vstart=0________________________________\|/______________               |
;       .                                   /|\                                                |
;       .                                    |                                                 |
;       .                                  putch                                               |
;       push ax                              |                                                 |
;putch:mov ax,string    ____________________\|/_________________________________               |
;       mov dh,0x07                                                                            |
;       .                                                                                      |
;       .                                                                                  program_end
;       .                                                                                      |
;SECTION data align=16 vstart=0                                                                |
;       .                                                                                      |
;       .                                                                                      |
;       .                                                                                      |
; string db 'How are you ?'                                                                    |
;       .                                                                                      |
;       .                                                                                      |
;       .                                                                                      |
;SECTION extra align=16 vstart=0                                                               |
;       .                                                                                      |
;       .                                                                                      |
;       .                                                                                      |
;SECTION stack align=16 vstart=0                                                               |
;       .                                                                                      |
;       .                                                                                      |
;       .                                                                                      |
;SECTION tail align=16                                                                         |
;program_end:_________________________________________________________________________________\|/_
;段header相对于整个程序开头的汇编地址是section.header.start=0
;段code相对于整个程序开头的汇编地址是section.code.start
;段定义语句还可以包含vstart=子句,这是因为尽管定义了段,但是引用某个标号时,该标号处的汇编地址依然是从整个程序的开头计算的,而不是从段的开头计算的
;使用vstart可以解决这个问题,putch是段code中的一个标号,原则上,该标号代表的汇编地址应该从程序头开始算,但是因为段code的定义中有vstart=0子句,所以标号putch的汇编地址要从它所在的段的开头从0开始算
;同样,引用标号string时,标号string所代表的汇编地址是相对于其所在段data的,也就是传送到ax中的数值是标号string相对于段data起始处的长度
;program_end所代表的汇编就是整个程序的长度(以字节计),因为SECTION tail没有包含vstart=0子句
;
;一般来说加载器和用户程序是在不同的公司不同的人开发的,两者之间不了解对方的结构和功能,双方黑盒,但也不能完全黑盒,加载器必须了解一些必要的信息以加载用户程序
;比如在用户程序内部某个固定位置包含基本的结构信息,加载器也固定在这个位置读取,一般放在程序头部
;                 ________________
;用户程序头部----->|    程序总长度    |<-----也就是双方都知道的协议部分
;                |      入口点     |
;                |  段重定位表项数   |
;                |    段重定位表    |
;                 --------------- |
;                |     用户程序    |
;                |   包括程序头部   |
;                |                |
;                |                |
;                |________________|
;
;                 ________________
;                |                |
;                |                |
;                |     加载器      |
;                |                |
;                |                |
;                 ----------------
;程序头部需要以一个段开始,也就是第7行的
;SECTION header vstart=0                     ;定义用户程序头部段
;并包含以下信息
;用户程序的尺寸(以字节计)
;       加载器根据这一信息决定读取多少个逻辑扇区
;       第8行伪指令dd定义一个双字(32位),因为程序可能很大,程序的长度取自程序中的一个标号,这是允许的,编译阶段,编译器将将标号所代表的汇编地址写在这里
;应用程序入口点
;       包括段地址和偏移地址,详细介绍在程序指令注释处,因为加载器并不清楚用户程序的分段情况,也不知道要执行的第一条指令在什么位置,并且第一条指令不一定位于代码段段内偏移地址为0的地方
;       且用户程序并非只有一个代码段,所以要给出第一条指令的段地址和偏移地址
;段重定位表
;       用户程序可能由多个段,段的用途不关加载器的事,但前提是程序加载到内存后,每个段地址必须重新确定,段的重定位是加载器的工作,加载器需要知道每个段在用户程序中的位置,即分别位于用户程序内的多少字节处
;       代码注释中由中括号括起来的十六进制数是当前代码的汇编地址,program_length  dd program_end          ;程序总长度[0x00],这条指令的汇编地址是0x00
;       用户程序的段数量是不确定的,所以程序第14行声明并初始化了段重定位表的项目数
;
;在用户程序中,段基地址是用标号引用来使用的,刚开始加载完用户程序,用户程序头部段里的段地址标号都只是各个段开头相对于用户程序开头的汇编地址
;这个相对于程序开头的汇编地址加上用户程序被加载的地址就是这个段的开头的物理地址,除以16将得到段基地址,然后这个重定位后的段基地址再写回用户程序头部段的重定位表项相对应段的标号处
;之后用户程序引用这个代表段基地址的标号就是正确的,因为这个标号处所存放的数据就是修正后(重定位)的段基地址
;
;关于屏幕字符显示
;要显示的内容位于段data_1中,该段正由DS指向,在屏幕上显示字符,所做的仅仅是填充显存,只要所填充的内容不超过一屏所能容纳的字符数,其他的事情不用自己操心,当字符在一行显示不下时,显示系统会自动移动到下一行接着显示
;不过有时候我们希望有自行换行的能力,而不管那一行是否到头(屏幕最右边),这么做的目的是为了格式化文本段落,在128个ASCII码中,大部分是可显示和打印的字符,部分是用于控制显示和打印那些字符的设备,0x0d回车,0x0a换行
;回车和换行的概念最早起源于老式打字机,打字机上有滚筒,用于使纸张上下卷动,每敲击一个键,字车往右移动一格,位于下一个可打印的位置,将字车推到最左边(一行的开始)就叫回车,而拧一下滚筒,将纸上卷一行,叫做换行
;如果回车加换行,那么字车将位于下一行的行首,叫做回车换行(Carriage Return Line Feed)
;
;在刚刚有电子计算机的时候,只能通过远程终端来分享计算力,这时候用的是电传打字机,不需要人工操作即可显示和打印字符,根据需要,回车换行还是需要的,怎么办?
;就是用ASCII码中的控制字符来命令电传打字机来做这件事,回车换行分配的分别是0x0d/0x0a
;在个人计算机时代,为了在屏幕上显示字符,ASCII码也被引入显示系统,不过当向显存中写入0x0d和0x0a时并不起作用,没有任何硬件对解释它们的意义负责,不过无所谓,对回车换行代码的解释可以由我们负责
;现在所要做的就是在需要回车换行的地方按照传统插入这两个代码,正是由于这个原因,第175~191行,凡是需要回车换行的地方,都使用0x0d和0x0a
;而在第191行,数值0,标志字符串结束,高级语言中常用
;
;
;屏幕光标的控制
;屏幕光标是在屏幕上有规律地闪动的一条小横线,通常用于指示下一个要显示的字符位置,基于硬件的光标只有在文本模式下才会出现
;光标在屏幕上的位置保存在显卡内部的两个光标寄存器中,每个寄存器是8位的,合起来形成16位的数值,比如0表示光标在屏幕上的第0行第0列,80表示它在第1行第0列,因为标准VGA文本模式是25行,每行80字符,屏幕右下角是1999
;光标寄存器是可读可写的,可以从中读出光标的位置,也可以写入一个值设置光标的位置
;显卡的操作非常复杂,内部的寄存器也不是一般的多,为了不过多占用I/O空间,很多寄存器只能通过索引寄存器间接访问
;索引寄存器的端口号是0x3d4,可以向它写入一个值,用来指定内部某个寄存器,比如两个8位的光标寄存器,其索引值分别是14(0x0e)和15(0x0f),分别用来提供光标位置的高8位和低8位
;指定了寄存器之后,要对它进行读写,这可以通过数据端口0x3d5进行
;
;put_char的工作流程      过程开始
;                       相关寄存器压栈保护
;                       取当前光标位置
;                       显示的字符是0x0d回车?
;                               是,计算光标在当前行行首时的位置数值---->重新设置光标---->相关寄存器出栈恢复---->过程返回
;
;                               否,显示字符是0x0a换行?
;                                       是,计算光标在下一行当前列时的位置数值---->光标是否越界?
;                                                                                   是,滚动屏幕内容---->重新设置光标---->相关寄存器出栈恢复---->过程返回
;                                                                                   否---->重新设置光标---->相关寄存器出栈恢复---->过程返回
;
;                                       否,在光标处显示字符并推进光标位置---->光标是否越界?
;                                                                                   是,滚动屏幕内容---->重新设置光标---->相关寄存器出栈恢复---->过程返回
;                                                                                   否---->重新设置光标---->相关寄存器出栈恢复---->过程返回
;
;返回指令的动作是从栈中弹出内容到IP,如果是原返回,则还需要弹出内容到CS,而使用jmp far需要事先在内存中存放另一个代码段的段地址和偏移,有空间代价,可以使用retf模拟段间返回